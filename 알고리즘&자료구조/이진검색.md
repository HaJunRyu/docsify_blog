# 이진검색(binarySearch)

## 조건

- 이진 검색(binary search)은 선형 검색과는 달리 정렬된 배열에서만 동작한다.

- 선형 검색은 배열의 모든 요소를 확인해야 하지만 이진 검색은 중간값과 검색 대상 값을 비교하여 검색 범위를 매번 반으로 줄여 나간다.

  - 검색 대상 값이 중간값보다 작은 경우 중간값보다 작은 쪽(왼쪽)을 검색 범위로 한정한다.

  - 검색 대상 값이 중간값보다 큰 경우 중간값보다 큰 쪽(오른쪽)을 검색 범위로 한정한다.

  - 검색 대상 값을 검색할 때까지 이와 같은 처러를 반복한다.

- 시간 복잡도: O(log n)

- 이진 검색을 통해 주어진 배열(array)에 주어진 값(target)이 요소로 존재하는지 확인하여 존재하는 경우 해당 인덱스를 반환하고 존재하지 않는 경우 -1을 반환하는 함수를 구현하라. 단, 아래의 빌트인 함수 이외에는 어떤 빌트인 함수도 사용하지 않아야 하며, while 문을 사용하여 구현하여야 한다.

- Math.floor: 전달받은 인수의 소수점 이하를 내림한 정수를 반환한다.

- Math.floor함수는 인수의 소수점 이하를 내림한 정수를 반환합니다.
- 양수의 경우, 소수점 이하를 떼어 버린 다음 정수를 반환합니다.
- 음수의 경우, 소수점 이하를 떼어 버린 다음 -1을 한 정수를 반환합니다.

## 풀이

함수 정의
```js
function binarySearch(array, target) {
  let start = 0;
  let end = array.length - 1;
  let mid = Math.floor(array.length / 2);

  while(array[mid] !== target) {
    if( start >= array.length || end < 0) return -1;
    
    target > array[mid] ? start = mid + 1 : end = mid - 1;
    mid = Math.floor((start + end) / 2);
  }
  return mid;
}
```

위의 함수를 호출한 결과
```js
console.log(binarySearch([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 6));              // 5
console.log(binarySearch([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13], 9));  // 8
console.log(binarySearch([1, 2, 3, 4, 5, 6, 7], 2));                        // 1
console.log(binarySearch([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11], -53));        // -1
console.log(binarySearch([1, 2, 3, 4, 5, 6, 7, 8, 9], 24));                 // -1
```

코드 요약

binarySearch라는 함수에 파라미터값을 2개 받는다. 
- 첫번째 파라미터는 배열객체를 받아야한다.
- 두번째 파라미터는 정수값을 받아야한다.
실제 서비스가 아닌 알고리즘 문제이기 때문에 다른 타입의 값이 들어올 경우를 고려한 방어코드는 생략하였다.

일단 변수를 3개 선언해주었고 모두 함수내에서 재할당이 이루어져야 하기 때문에 let키워드를 이용해 선언해주었다.

1. `let start = 0; // 이진검색의 시작범위를 지정한다.`
2. `let end = array.length; // 이진검색의 끝 범위를 지정한다. 초기값은 파라미터값으로 받아지는 배열의 마지막 인덱스이다.`
3. `let start = 0; // start와 end를 기준으로 가운데 숫자를 검색할때 사용한다. start와 end를 기준으로 매번 절반씩 줄어들것이다.`

그리고 이 변수를 활용해 배열을 순회할 while문이 작성이 된다.
while문의 조건식은 start와 end의 중간값인 mid를 이용한다. 이때 만약 파라미터로 받은 배열의 length가 10일 경우 mid의 초기값은 5가, 100일 경우 50이 될것이다.

array의 mid번째 index에 존재하는 값과 2번째 파라미터로 받은 target의 값이 동일하지 않을경우 `array[mid] !== target` while문을 순회하게 되는데 이때 네가지 경우의 수가 있다. 만약 1 ~ 10까지의 값을 가지고 있는 length가 10인 배열을 첫번째 파라미터로 받았다고 가정해보자. 이때 mid변수의 초기값은 5가 될것이다.

1. target(두번째 파라미터)이 배열의 mid번째 index에 존재하는 값보다 클때
  - mid번째 보다 낮은숫자의 index는 검색 할 필요가 없어졌다. 검색범위의 시작을 지정해주는 start변수의 값을 mid값 + 1로 설정해준다. 여기서 +1을 해주는 이유는 이미 mid값의 index는 검색이 끝났기때문에 검색영역에서 제외해주기 위함이다.
  - 이제 start는 6, end는 그대로 9이다. 여기서 start + end를 하고 2로 나누어주면 6 ~ 9의 중간값이 나오는데 실수(소수점)가 나올 수 있기때문에 Math.floor메서드를 사용해주어 mid변수에 담아준다. `(6 + 9) / 2 === 7`
  - 그리고 다시 while문의 조건식으로 돌아가게 되고 mid번째 index값을 비교해 3가지 경우의 수를 다시 체크한다.

2. target(두번째 파라미터)이 배열의 mid번째 index에 존재하는 값보다 작을때
  - mid번째 보다 높은숫자의 index는 검색 할 필요가 없어졌다. 검색범위의 시작을 지정해주는 end변수의 값을 mid값 - 1로 설정해준다. 여기서 -1을 해주는 이유는 이미 mid값의 index는 검색이 끝났기때문에 검색영역에서 제외해주기 위함이다.
  - 이제 start는 그대로 0, end는 4이다. 여기서 start + end를 하고 2로 나누어주면 0 ~ 4의 중간값이 나오는데 start의 수와 end의 수에 따라 실수(소수점)가 반환될 수 있기때문에 Math.floor메서드를 사용해주어 mid변수에 담아준다. `(0 + 4) / 2 === 2`
  - 그리고 다시 while문의 조건식으로 돌아가게 되고 mid번째 index값을 비교해 3가지 경우의 수를 다시 체크한다.

3. target(두번째 파라미터)이 배열의 mid번째 index에 존재하는 값과 동일할때
  - 처음부터 target의 값과 mid의 값이 같은 경우가 있고 반복문을 돌다보면 target의 값이 배열에 존재하는 이상 이 조건식은 무조건 true가 될때가 있을 것이고 그때 while문을 탈출하여 mid의 값을 return 하게 된다.

4. target(두번째 파라미터)의 값이 배열에 존재하지 않을때
  - 이진검색을 수행하며 값을 찾을때까지 start는 늘어날것이며 end는 줄어들것이다. 하지만 index는 0보다 작은 수는 없으며 length와 같거나 큰 index도 존재하지 않는다. 그러므로 값이 없을때는 start가 배열의 index보다 값이 커졌을때 -1을 반환하며 함수가 종료되게 해줬고 end가 0보다 작아질때도 마찬가지로 -1을 반환하며 함수가 종료되게끔 구현해주었다.
   