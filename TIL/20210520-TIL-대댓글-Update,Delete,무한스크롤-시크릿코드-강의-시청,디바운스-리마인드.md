# 2021년 05월 20일 목요일 TIL(대댓글 Update, Delete, 무한스크롤 시크릿코드 강의 시청, 디바운스 리마인드)

## 오늘 한 일과 느낀점
- 댓글, 대댓글의 Delete 구현했다. 사실 내부적으로 따지면 Update인데 왜냐면 UI에서 그려지기엔 Delete가 되는것처럼 삭제 기능을 구현했지만 사실은 데이터베이스의 컬럼 값 하나를 이용하여 삭제가 된 것을 판단하고 렌더링을 `삭제 된 댓글 입니다.` 라고 해줬기 때문이다. 근데 여기서 생각치 못한 이슈가 생겼다. 사실 기능 상 딱 보여지는 이슈라기 보단 설계상의 미스인데 댓글 테이블은 user, project이렇게 두 테이블의 pk를 외래키로 사용하고 있다. 그래서 project를 삭제하면 실제로 댓글이 삭제되는데 이건 자연스러운 현상이고 데이터를 보관하지 못한다뿐이지 설계상의 버그사항은 아니다. 하지만 user가 회원탈퇴를 했을때는 이야기가 다르다. 이렇게 삭제를 Update기능으로 구현 한 이유가 대댓글 기능이 있기 때문인데 댓글을 작성 한 유저가 회원탈퇴를 하면 외래키를 ON DELETE CASCADE 옵션으로 설정해놓았기 때문에 실제로 그 댓글이 삭제가 된다. 하지만 그 댓글에 종속된 대댓글은 아직 삭제가 되지 않았음에돕 불구하고 댓글의 부재로 렌더링이 되지 못하게 된다. 버그사항이라고까지는 못하겠지만 사실 나의 설계와 다르게 작동하는것이니 이슈사항은 맞다고 생각한다. 사실 ON DELETE CASCADE말고 다른 외래키의 변경, 삭제에 대한 옵션을 사용해본적이 없어 잘 모르지만 ON DELETE SET NULL을 이용하면 가능할지도 모르겠다는 생각을 했다.

- 댓글 대댓글의 내용을 변경해주는 Update기능을 구현했다. 사실 어제는 Update기능에 대해 겁을 좀 먹고 있었는데 딱 일정시간 집중하여 개발하니 생각보다 그렇게 어렵지 않았고 수월하게 해결이 되었다. 아직 해보지 않고 어려울거 같다고 느껴지는 기능들이 당연히 있을건데 이런것에 대한 선입견을 고치려는 노력도 조금은 필요해보이는것 같다.

- 프로젝트 데이터의 렌더링을 무한스크롤 UI를 이용하여 구현하려고 패캠 인강 시크릿코드의 예제 강의를 참고했다. 처음에는 scroll이벤트를 root요소에 걸어주고 해당 이벤트가 발생할때 target 내부의 scrollingElement객체의 프로퍼티들을 이용하여 구현을 하는 예제였다. 간략히는 body의 height값이 곧 root요소의 scrollHeight값과 동일하고 (root요소 상위에는 당연히 아무 요소가 없다는 가정) 그 값은 스크롤을 맨 밑으로 내렸을시의 scrollTop의 값 + 현재 뷰포트에 보여지는 root요소의 clientHeight 값과 같았다. 그래서 결국은 스크롤을 맨 밑으로 내렸을때 이벤트를 발생시키는데 그때 데이터를 불러와주는 로직을 짜면 된다는것이다. 하지만 이슈 사항은 스크롤 이벤트는 정말*100 빈번하게 발생하는 이벤트이고 이벤트핸들러(함수)가 그때마다 호출되면 성능상 악영향이 있는것이다. 그래서 디바운스를 가장 간략하게 구현하여 사용하는 예제를 사용했는데 오랜만에 디바운스를 직접 구현하는 코드를 보니 이해가 되지 않았다. 이해가 안되니 당연히 코드를 뜯어봐야하고 어이없게도 debounce함수 자체는 이벤트를 등록할때 한번만 실행이 되는 구조였는데 매번 실행이 된다고 착각하여 자유변수가 계속 초기화 된다고 생각하고 있어 대략 15 ~ 20분정도를 코드만 뚫어져라 쳐다봤던것 같다. 다행히 뚫어져라 쳐다보다보니 그게 아니라는걸 깨닫긴 했는데... 어쨋든 잘 기억나지 않던 지식을 리마인드했더니 이제 한층 더 나의 지식이 된 것 같아 기분이 넘 좋았다. 쾌감같은...

- 무한스크롤 UI를 intersectionObserver라는 비교적 최신의 Web API를 사용해서 구현하는것도 강의 영상에서 소개해주었다. 사실 패스트캠퍼스 리액트 강의에서 야무 강사님이 소개도 많이 해주시고 어떤것이라고 많이 설명도 해주셨는데 사실은 좀 어려운 개념이라고 또 겁을 먹고 있었던것 같다. 사실 이제 처음 실제로 쓰는법의 일부를 배운것이라 그럴지 모르는데 보니까 너무... 간단했다 말도 안되게 간단하고 디바운스나 스로틀같은것 없이도 아주 간단하게 성능까지 고려할 수 있는 코드를 작성할 수 있는 API인것 같아 내일 빨리 무한스크롤을 구현하며 써보고 싶은 마음이 들었따. 이렇게 긍정적인 새로운 기술은 언제든 환영이고 사실... 배울때 잠깐 귀찮고 개발할때 항상 편하게 개발하고 싶다😹

## 내일 할 일
- ProjectItem 컴포넌트에 프로젝트에 달린 댓글이 몇개인지 알려주는 기능(UI)추가

- 홈페이지 및 프로젝트 데이터를 렌더링 해야하는곳에서 끼워주기만 하면 사용할 수 있게 무한스크롤 컴포넌트를 만든다. 대충... 일단 무한스크롤이 적용되는 페이지 컴포넌트들에서는 FooterBar컴포넌트를 제거해주고 페이지 당 몇개의 프로젝트를 응답받을것인지 props로 전달, observe할 컴포넌트의 ref를 props로 전달받는등... 사실 지금 머릿속으로 딱 그려지지는 않고 내일 부딪혀 봐야 할 수도 있을것 같다. 사실 홈페이지, 포트폴리오 페이지, 좋아한 프로젝트를 모아 볼 수 있는 페이지 모두 다른 데이터를 요청해야 하기 때문에 그냥 따로따로 구현하는게 더 나을지도 모른다는 생각도 든다.

- 데이터베이스에서 ON DELETE SET NULL에 대해서 외래키만 바뀌는지 알아보기

- 위의 작업이 끝나고 시간이 된다면 jwt토큰으로 CRUD등의 server요청에서 인증상태를 검증해줄 수 있는 코드에 대해 알아보고 구상하기
