# 2021년 05월 21일 금요일 TIL(MySQL JOIN개념 공부 및 쿼리문 작성, IntersectionObserver 무한스크롤)

## 오늘 한 일과 느낀점
- RDMS의 꽃인 JOIN문에 대한 기본 개념에 대해 공부했다. 배웠던적이 있었지만 프론트엔드를 공부하는 지금 내 머릿속에는 JOIN이 뭐하는놈인지만 남아있고 동작원리나 심화적인 사용법은 존재하지 않는다 하하하... 사용 목적은 무한스크롤 예제를 진행하며 인기순, 최신순으로 프로젝트를 정렬할때 원래 하나의 쿼리문으로 클라이언트에서 정렬해주었는데 사실 무한스크롤의 장점이 첫 로딩 시간을 줄여주는것이다보니 한번의 쿼리문에서 한정된 데이터만을 가져오게끔 변경해야하고 그렇게 되면 인기순, 최신순 정렬을 서버에서 해주어야하는데 최신순은 사실 정말 쉽다. 하지만 인기순은 project, project_likes 2개의 테이블의 컬럼들을 조합하여 쿼리를 작성해줘야해서 당연히 JOIN을 처음에 사용은 했지만 계속 중복된 데이터들이 여러개 담긴 데이터만 반환되었고 이건 무작정 쿼리를 쓰는것보다 개념을 정확히 알아보고 하는게 나을것 같아 생활코딩에서 정말 간략히 11분짜리 MySQL JOIN 영상을 시청하였고 바로 아주 간단히 구현이 되었다. 그리고 뒤에 LIMIT절을 붙혀주어 현재 page * limit번째 데이터부터 limit만큼의 데이터를 반환하게끔 구현하였다.

- 서버쪽 로직을 변경해 준 후 무한스크롤을 구현하는데 IntersectionObserver를 사용하였다. 특정 DOM요소를 observe하여 뷰포트에 들어왔을때 일정 갯수의 데이터를 요청하도록 구현했는데 기존에 있던 Skeleton요소를 observe시켜 데이터를 불러오게끔 구현을했다. 그래서 일반적인 경우엔 작동을 잘 한다. 하지만 스크롤을 너무 빨리 내린다거나 스크롤이 아래쪽에 내려와있는 상태에서 리프레시를 했을때 데이터가 불러와지지 않고 스켈레톤이 사라지지도 않고 계속 보여지는 이슈(버그)가 발생하였다. 그냥 로직 자체를 잘못 설계한것 같고 리팩토링을 무조건 해주어야겠다.

## 내일 할 일
- IntersectionObserver를 이용한 무한스크롤 버그 해결을 위한 리팩토링
