# 2021년 03월 19일 금요일 TIL (compound component, useState콜백, useEffect)

## 오늘 한 일과 느낀점
- 오전 10시 ~ 오후 5시 리액트 강의  
오전시간에는 어제 예제로 진행했던 Counter를 변형하여 Counter컴포넌트에서 관리하던 상태를 Lifting State Up하여 상위 컴포넌트에서 상태를 관리하며 Counter에 그 값을 props로 전달하여 관리하게끔 바꿔주어 봤다. 그리고 거기서 추가적으로 compound component로 컴포넌트의 static멤버로 하위 컴포넌트를 넣어주어 각자가 따로 불러지는게 아닌 Display라는 컴포넌트는 Counter 컴포넌트의 static멤버로써 사용하는 방법도 배워봤다. compound component패턴은 props로 일일히 상태를 전달하는게 아닌 static컴포넌트끼리 내부 state를 공유하며 서로 상호작용하게끔 하여 컴포넌트의 내부 로직은 추상화하여 사용자가 사용할때 필요한 로직을 독립적으로 작성할 수 있게끔 해주는 패턴이라고 한다. 아직 실제로 코드로 써본것이 아니라 체감하지는 못했다.  

  그리고 useEffect에 대해 설명을 들었다. 미리 예습했어서 어느정도 내용을 알았지만 처음 알게 된 것은 LayoutEffect라는게 따로 있고 이것은 useEffect를 사용하며 나온 UI가 무너지는 이슈들 때문에 만들어진 것이고 하는일은 useEffect와 비슷하지만 특수한 경우에만 사용한다는것이라고 강사님이 설명을 해주셨다.  

  그리고 Hooks를 공부할때 아무래도 라이프사이클 메서드와 비교하게 되는것 같은데 그래서 오늘 useEffect의 cleanup함수가 클래스 컴포넌트의 getSnapshotBeforeUpdate메서드와 비슷하지 않냐고 강사님께 질문을 드렸고 돌아온 대답은 너무 Hook과 라이프사이클 메서드를 비교하려고 하지 말라고 하셨다. 비슷한 동작을 하게끔 구현을 해놓은것뿐이지 내부 로직은 완전히 다르고 useEffect는 정말 희안하게 만들어 이슈도 많다는 말씀을 해주셨다. 앞으로도 Hook을 공부할때 너무 라이프사이클 메서드와 똑같이 생각하지 말고 그냥 참고를 하는정도로만 생각을 해야겠다.  

- 오후 7시 ~ 오후 10시 쿠팡 페이지, 컨테이너, 컴포넌트 UI 완성  
어제 하던 쿠팡예제를 이어서 진행했다. 어제와 같은 멤버들과 진행했고 오늘은 사실 어제보다 속도가 더 안나왔다... 두명 다 알려주면서 진행하려니 속도가 너무 느리게 나오고 같은 설명을 두번씩 반복하는 경우도 있어서 지연이 많이 됐던것같다. 원래의 목표는 컴포넌트를 이용해 페이지 UI를 모두 구성하고 페이지 컴포넌트에서 상태를 관리하여 자식 컴포넌트들에게 props로 상태와 상태를 변경하는 함수를 전달하여 동적인 페이지를 만들어보는것까지가 목표였는데 딱 UI구현이 끝나니까 오후 10시가 됐다.

## 내일 할 일
- 쿠팡예제 페이지 컴포넌트에 상태를 추가하여 동적인 페이지 구현하기

- useCallback, useRef, 커스템 Hooks만들기까지 읽고 시간이 된다면 Hooks파트의 내용을 모두 읽기(리액트를 다루는 기술 서적)

## 리액트 수업 메모
### 컴포넌트 컴포넌트
컴포넌트 내부에서 클래스멤버로 컴포넌트를 정의하는게 컴포넌트 컴포넌트(컴파운드 컴포넌트) 방식이다.
그래서 만약 Counter컴포넌트 안에서 statc Display라고 정의한다면 `<Counter.Display />`이렇게 사용할 수 있을것이다. 왜냐하면 결국은 위의 코드는 `React.createElement(Counter.Display);` 라고 변환될것이기 때문이다.

근데 그냥 화살표 함수로 정의하면 익명 컴포넌트로 렌더링 되기때문에 컴포넌트 컴포넌트는 이름이 있는 함수로 정의하거나 Component.displayName = '컴포넌트 이름' 으로 익명 컴포넌트의 이름을 개발자가 지정해 줄 수 있다.

useState에 콜백함수를 넣게 되면 지연된 처리로 동기적으로 코드를 처리하게 된다. 즉, 코드의 실행순서를 보장시켜준다. 그러니 만약 state의 초깃값을 비동기처리가 끝난 이후 설정해야한다면 콜백함수를 넣어주는 패턴을 사용하면 될 것이다.

cleanup함수는 매우 중요하다 뒷정리함수인데 왜냐하면 SPA에서는 페이지가 전환되지 않고 계속 쌓이게 되니까 만약 이벤트를 등록해줬다가 컴포넌트가 언마운트 되어도 이벤트가 삭제되지 않았다면 남아있는 이벤트들이 에러를 발생시킬수도 있고 쓸데없는 메모리를 점유하고 있는 상태가 되기 때문이다.