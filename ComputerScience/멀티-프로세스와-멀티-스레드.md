# 멀티 프로세스와 멀티 스레드(Munti Process, Multi Thread)

## 프로세스는 서로 어떻게 통신하는가
프로세스 간 통신(Inter-Process-Communication, IPC)이란 프로세스들 사이에 서로 데이터를 주고받는 행위 또는 그에 대한 방법이나 경로를 뜻한다.  
프로세스는 자신에게 할당된 메모리 내의 정보만 접근 할 수 있기 때문에 프로세스끼리 데이터를 공유하려면 IPC를 사용해야 한다.

IPC에는 두 가지 표준이 있다.
- System V IPC  
System V IPC는 조금 오래된 버전이고 POSIX IPC가 비교적 최근에 개발된 표준이다. System V IPC는 오랜 시간 사용된만큼 코드 호환성을 확실히 보장해주지만 API가 오래되었으며 함수명도 명확하지 않다.  

- POSIX IPC  
POSIX IPC는 직관적으로 API가 구성되어 있어 상대적으로 조금 더 사용하기 쉽다.  

IPC도 각각의 필요성에 따라 다양한 설비들이 존재한다.
- PIPE (익명 PIPE)
PIPE는 두 개의 프로세스를 연결하게 되고, 하나의 프로세스는 데이터 쓰기, 다른 하나는 데이터 읽기만을 할 수 있다. 단방향으로만 통신이 가능한 특징 때문에 Half-Duplex(반이중) 통신이라고 부르기도 한다. 만약 프로세스 간 읽기와 쓰기(데이터 송/수신)를 모두 하기 원한다면 2개의 파이프를 만들어야만 가능해진다. 하지만 그렇게 되면 구현이 꽤나 복잡해질 수 있고 결론적으로는 양방향 통신을 고려해야 하는 상황에는 PIPE는 좋은 선택이 아니다. 그리고 익명 PIPE같은 경우에는 PPID가 같은(같은 부모 프로세스를 가진) 프로세스들 사이에서만 통신이 가능하다.  

- Named PIPE(FIFO)
PIPE(익명 파이프)는 통신을 할 프로세스가 명확하게 알 수 있는 경우 사용한다. 예를 들어 부모와 자식 프로세스간의 통신에는 사용할 수 있으나 전혀 상관없는 프로세스들끼리 통신을 하려면 Named PIPE를 사용해야한다. 익명 PIPE와 다르게 PPID가 다른 전혀 다른 모든 프로세스들 사이에서 통신이 가능하다. 그 이유는 프로세스 통신을 위해 이름이 있는 파일을 사용하기 때문이다. Named PIPE의 생성은 mkfifo를 통해 이루어지는데 mkfifo가 성공하면 이름이 정해진 파일이 생성된다.  
하지만 Named PIPE 또한 데이터를 단방향으로만 주고받을 수 있다. 그래도 파일의 이름을 가지고 있기 때문에 두개의 PIPE와 FIFO를 만들어 양방향 통신을 지원할 수도 있다.  

- Message Queue
Queue는 선입선출의 자료구조를 가지는 통신설비로 커널에서 관리한다. 입출력 방식으로 보면 Named PIPE와 같다고 볼 수 있다. Named PIPE와 다른 점이라면 Name PIPE는 데이터가 흐름이라면 Message Queue는 메모리 공간이라는 점이다. 파이프가 아닌, 주소를 가지고 어디서나 꺼내쓸 수 있는 구조라고 생각하면 될 것 같다. 그렇기 때문에 여러 개의 프로세스가 동시에 데이터를 쉽게 다룰 수 있다.  

- Shared Memory(공유 메모리)
Shared Memory방식은 통신을 이용해 데이터를 주고 받는것이 아닌 그냥 데이터를 아예 공유해버리는 방식이다. 프로세스는 자신만의 메모리 영역을 가지고 있고, 이 메모리 영역은 다른 프로세스가 접근해서 함부로 데이터를 읽거나 쓰지 못하도록 커넬에 의해 보호가 되는데, 만약 다른 프로세스의 메모리 영역을 침범하려고 하면 커널은 침범 프로세스에 SIGSEGV(경고 시그널 - 할당된 메모리의 범위를 벗어나는곳에서 읽거나, 쓰기를 시도할 때 발생)를 보내게 된다.  
이것을 프로세스간 메모리 영역을 공유할 수 있게 허용하는것이 Shared Memory 방식인것이다. 프로세스가 공유 메모리 할당을 커널에 요청하면 커널은 해당 프로세스에 메모리 공간을 할당해준다. 그 이후부터는 해당 메모리영역은 어떤 프로세스건 상관없이 접근할 수 있게 된다.  
Shared Memory는 중개자 없이 곧바로 메모리에 접근 할 수 있기 때문에 다른 모든 IPC들 중에서 가장 빠르게 작동할 수 있다.  

- Memory Map
Memory Map도 Shared Memory와 마찬가지로 메모리를 공유한다는 측면에서 서로 비슷하게 볼 수 있다. 하지만 차이점이 있는데 Memory Map은 열린파일을 메모리에 맵핑시켜 공유한다는 점이다. 파일은 시스템의 global한 자원이므로 서로 다른 프로세스들끼리 데이터를 공유하는데 문제가 없을것이다.  

- Socket
프로세스가 네트워크 세계로 데이터를 내보내거나 혹은 받기 위한 실질적인 창구 역할을 한다. 그렇기 때문에 프로세스가 네트워크를 통해서 데이터를 보내거나 받기 위해서는 반드시 소켓을 열어 소켓에 데이터를 써서 보내거나 소켓으로부터 데이터를 읽어들여야 한다.  
Socket의 개념은 조금 깊기 때문에 따로 포스팅 하나를 하여 다루어야겠다.  

- Semaphore
Semaphore는 프로세스 간 데이터를 동기화 하고 보호하는데 목적이 있다. 프로세스끼리 메시지 전송을 하거나, 혹은 Shared Memory를 통해 특정 데이터를 공유하게 될 경우 발생하는 문제가 있는데, 공유된 자원에 여러개의 프로세스가 동시에 접근하면 안되며, 단지 한번에 하나의 프로세스만 접근 가능하도록 만들어주어야 할 것이다. 스레드 동기화에서도 사용되는 개념이지만 공유된 하나의 자원에 동시적으로 여러개의 프로세스가 접근할 수 없게 만들어주는것이다.


## 스레드란?
스레드(Thread)란 어떠한 프로그램 내에서, 특히 프로세스 내에서 실행되는 흐름의 단위를 말한다. 일반적으로 한 프로그램은 하나의 스레드를 가지고 있지만, 프로그램 환경에 따라 둘 이상의 스레드를 동시에 실행할 수 있다. 이러한 실행 방식을 멀티 스레드(multi-thread) 라고 한다. (Light Weight Process라고 부르기도 함)

## 스레드와 프로세스의 차이점
멀티프로세스와 멀티스레드는 양쪽 모두 여러 흐름이 동시에 진행된다는 공통점을 가지고 있다. 하지만 멀티 프로세스에서 각 프로세스는 독립적으로 실행되며 각각 별개의 메모리를 차지하고 있는 것과 달리 멀티스레드는 프로세스 내의 메모리를 공유해 사용할 수 있다. 따한 프로세스 간의 전환 속도보다 스레드 간의 전환 속도가 빠르다.

### 멀티스레드의 장점
- CPU 코어가 여러 개일 경우 각각의 코어가 스레드 하나씩을 담당하는 방법으로 속도를 높일 수 있다. 스레드는 프로세스와 달리 실제로 병렬적 즉, 동시에 여러가지 작업을 할 수 있기 때문이다.

- 스레드를 많이 생성하면 Context Switching이 많이 일어나게 되어 성능이 저하된다. (OS에서 모든 스레드를 스케줄링 해야함)
- 멀티스레드의 단점은 각각의 스레드 중 어떤 것이 먼저 실행될지 그 순서를 예측할 수 없다는 것인다. 그렇기 때문에 프로그램이 의도치 않는 결과를 내뿜는 경우가 있어 스레드를 동기화 해주어야 한다.

## 스레드 동기화가 무엇이고 왜 사용해야하는가
스레드 동기화란 병렬적으로 작업을 하는 스레드들의 작업들 사이에 실행 시기를 맞추어놓는것이다. 멀티스레드로 프로그램을 구성할때 사용하는것인데 스레드는 각각 어떤것이 먼저 실행될지 모른다고 했는데 만약 두 개 이상의 스레드가 하나의 데이터에 접근하여 동시에 변경한다고 가정했을때 아마 개발자의 의도대로 코드가 작동하지 않을것이고 심각하면 프로그램이 아예 멈춰버릴 수도 있다. 그래서 멀티스레드 방식으로 프로그램을 개발할때는 스레드를 동기화해줘야 한다.  
스레드의 동기화는 임계 자원(critical resource)에 대하여 임계 영역(critical section)을 설정하여 다른 스레드들이 접근하지 못하게끔 막아주는 방법이다.

### 뮤텍스와 세마포어
스레드의 동기화 기법이 여러가지 있지만 오늘 배운 뮤텍스와 세마포어의 차이점이다.
- 뮤텍스(mutex) : 공유 리소스에 대해 오직 단 하나의 스레드만 접근을 허용
- 세마포어(semaphore) : 공유 리소스에 대해 접근할 수 있는 스레드의 갯수를 한정, 한정된 갯수보다 많은 스레드가 공유 리소스를 사용하려고 할때 접근을 제한  

## 멀티 프로세스, 멀티 스레드 서로 언제 사용해야하는가
둘 다 병렬적인 처리로 짧은 반응 시간과 성능 개선때문에 사용하지만 장단점이 존재하기 때문에 확실한 구분점은 없다고 생각하지만, 기본적으로 스레드는 하나의 프로세스안에 있는 자원들을 모두 공유할 수 있기 때문에 IPC같은걸 쓰지 않아도 되어 성능적인 측면에서 더 유리하기 때문에 하나의 자원을 동시에 접근하는 경우가 아니면 보통 멀티스레드를 써야한다고 생각하고 만약 프로세스에서 각각의 여러개의 자원들을 모든 스레드가 동시다발적으로 접근하는 경우가 발생하는 코드에서는 일일히 임계 영역을 지정하여 막아주는 방법도 있지만 뮤텍스 방식을 사용하면 멀티스레드의 장점이 상쇄되는것도 있고 개발자의 역량으로 도저히 100% 완벽하게 임계영역을 지정하여 안정적인 코드를 만들 수 없다고 판단되면, 혹은 프로그램이 성능보다 안정성이 우선이라면 프로세스마다 독립적인 자원을 갖는 멀티프로세스를 써야한다고 생각한다.  

## 질문사항
- 멀티 스레드는 Stack을 제외한 모든 메모리를 공유한다고 하는데 자바스크립트는 클로저의 개념이 있어서(자바스크립트 뿐만이 아닌 함수형 프로그래밍 언어(하스켈, 리스프, 얼랭, 스칼라 등)) Stack영역에서 만들어진 변수를 함수의 밖에서 사용하는 경우가 있는데 만약 멀티 스레드 기능을 지원한다고 했을때 그러면 그러한 자원들은 스레드들끼리도 공유할 수 없는것인지? 아니면 어차피 그 함수를 Data영역에 다시 담아줄거라 상관이 없는건인지...

- 프로세스 IPC에도 Shared Memory의 개념이 있고 Semaphore의 개념이 있는데 잘 사용하지 않는 이유는 그리고 IPC중 가장 일반적으로 사용하는 방식이 어떤것인지